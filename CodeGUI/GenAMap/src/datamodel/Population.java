package datamodel;

import control.itempanel.DeletionItem;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import realdata.DataManager;
import control.itempanel.ThreadingItemFrame;
import static javax.swing.WindowConstants.HIDE_ON_CLOSE;

/**
 * Population structure goes with a markerset and is stored in the database.
 * For each markerset, a population structure is a series of values that deal with
 * the sample and assigns each sample to a particular value of a population. 
 * @author akgoyal
 */
public class Population implements Serializable
{
    /**
     * The database id of this population structure
     */
    private int id;
    /**
     * The name of this population set.
     */
    private String name;
    /**
     * The markerset that this population structure belongs to. 
     */
    private MarkerSet ms;

    /**
     * Creates a new population object with its database id
     * @param ms the markerset this population object belongs to
     * @param name the name of this population set
     * @param ID the database id fo this pouplation set
     */
    public Population(MarkerSet ms, String name, int ID)
    {
        this.ms = ms;
        this.id = ID;
        this.name = name;
    }

    /**
     * Returns the name of this population object
     * @return
     */
    public String getName()
    {
        return name;
    }

    /**
     * Queries that database to find out the total number of populations
     * present in a user loaded dataset.
     * @return the largest population assignment in the dataset.
     */
    public int getTotPopIfUserGen()
    {
        ArrayList<String> whereargs = new ArrayList<String>();
        whereargs.add("popstructid=" + this.id);
        ArrayList<String> res = DataManager.runSelectQuery("pop1", "structure", true, whereargs, null);
        int toreturn = -1;
        for (int s = 0; s < res.size(); s++)
        {
            if (toreturn < Integer.parseInt(res.get(s)))
            {
                toreturn = Integer.parseInt(res.get(s));
            }
        }

        return toreturn;
    }

    /**
     * Creates an array of counts for how many individuals are in each
     * subpopulation by querying the database.
     * @param totalpopulation the total number of populations or 1 if the user
     * uploaded the dataset
     * @param totifusergenerated the total number of populations.
     * @return a count for each population
     */
    public int[] getPieChartCounts(int totalpopulation, int totifusergenerated)
    {
        ArrayList<String> cols = new ArrayList<String>();
        cols.add("pop" + totalpopulation);
        ArrayList<String> whereargs = new ArrayList<String>();
        whereargs.add("popstructid=" + this.id);
        int[] toreturn = new int[totifusergenerated];

        ArrayList<HashMap<String, String>> res = DataManager.runMultiColSelectQuery(cols, "structure", true, whereargs, null);
        for (HashMap<String, String> netEdge : res)
        {
            int popno = Integer.parseInt(netEdge.get("pop" + totalpopulation));
            toreturn[popno - 1]++;
        }
        return toreturn;
    }

    /**
     * Runs a query against the database to detect whether or not the dataset
     * has generated eigen values for the population. 
     * @return true if eigen values are ready for the dataset.
     */
    public boolean isEigenGenerated()
    {
        ArrayList<String> whereargs = new ArrayList<String>();
        whereargs.add("popstructid=" + this.id);
        ArrayList<String> res = DataManager.runSelectQuery("eig1", "structure", true, whereargs, null);
        if (res.get(0).compareToIgnoreCase("") == 0)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

    /**
     * Runs a query against the database to find out if the dataset was uploaded
     * by a user, and is therefore in pop1, or if the dataset was generated
     * by structure, and is therefore in pop2-pop10.
     * @return true if it was generated by structure and has 10 population options.
     */
    public boolean isStructureGenerated()
    {
        ArrayList<String> whereargs = new ArrayList<String>();
        whereargs.add("popstructid=" + this.id + "");
        ArrayList<String> res = DataManager.runSelectQuery("pop1", "structure", true, whereargs, null);
        if (res.get(0).compareToIgnoreCase("") == 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /**
     * Queries the database and gets data to generate a scatter plot of the
     * population data. The samples are plotted by eigen value and colored
     * by their population assignment.
     * @param eig1 which eigen index to use for the x axis
     * @param eig2 which eigen index to use for the y axis. 
     * @param totalpopulation
     * @return
     */
    public ArrayList<HashMap<String, String>> getScatterData(int eig1, int eig2, int totalpopulation)
    {
        ArrayList<String> cols = new ArrayList<String>();
        cols.add("eig" + eig1);
        cols.add("eig" + eig2);
        cols.add("pop" + totalpopulation);
        ArrayList<String> whereargs = new ArrayList<String>();
        whereargs.add("popstructid=" + this.id);
        ArrayList<HashMap<String, String>> res = DataManager.runMultiColSelectQuery(cols, "structure", true, whereargs, null);
        return res;
    }

    /**
     * Renames the population object to the new name. 
     * @param newName
     */
    public void rename(String newName)
    {
        ArrayList<String> where = new ArrayList<String>();
        where.add("id = " + id);
        DataManager.runUpdateQuery("popstruct", "name", newName, where);
        this.name = newName;
    }

    /**
     * Returns the id of this population object. 
     * @return
     */
    public int getId()
    {
        return this.id;
    }

    /**
     * Removes this population object from the database.
     */
    public void delete()
    {
        ThreadingItemFrame tif = ThreadingItemFrame.getInstance();
        DeletionItem di = new DeletionItem(tif, this.ms.getId(), DeletionItem.DELETE_POPSTRUCT,
                this.name);
        tif.addToThreadList(di);
        tif.setVisible(true);
        tif.setDefaultCloseOperation(HIDE_ON_CLOSE);
    }

    @Override
    public String toString()
    {
        return name;
    }
}
