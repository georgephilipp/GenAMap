/*
 * TraitUploaderFrame.java
 *
 * Created on Sep 21, 2010, 10:22:26 AM
 */
package control.itempanel;

import java.util.Observable;
import java.util.Observer;
import javax.swing.DefaultListModel;

/**
 * This frame holds all threads currently executing ... although we only
 * have some of them actually working at a time. The user can start and
 * pause them from this screen. Pausing actually only sends them into a
 * loop where they wait for the signal to press forward.
 *
 * Each task can be removed from the list once it has errored out or
 * been deleted. 
 * @author flaviagrosan
 */
public class ThreadingItemFrame extends javax.swing.JFrame implements Observer
{

    /**
     * the list of running threads
     */
    private final DefaultListModel threadList = new DefaultListModel();
    /**
     * The current running thread on proc1
     */
    private static int runningProc1 = -1;
    /**
     * The second current running thread
     */
    //private static int runningProc2 = -1;
    /**
     * The counter of threads in queue. 
     */
    private int procNo = 0;
    /**
     * Don't start running jobs until the application has finished loading
     */
    private boolean canStartJobs = false;

    /**
     * Private constructor of the singleton instance of this class.
     */
    private ThreadingItemFrame()
    {
        initComponents();
    }
    /**
     * Create an instance upon building time. The instance of this class
     * will be accessed by any code wishing to interact with the database
     * through a thread (which should be about everything). 
     */
    private static final ThreadingItemFrame instance = new ThreadingItemFrame();

    /**
     * Returns the running instance of this class. 
     * @return
     */
    public static ThreadingItemFrame getInstance()
    {
        return instance;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        guiThreadList = new javax.swing.JList();
        jPanel1 = new javax.swing.JPanel();
        removeBtn = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        guiThreadList.setModel(threadList);
        guiThreadList.setCellRenderer(new ItemPanel());
        guiThreadList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                guiThreadListValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(guiThreadList);

        removeBtn.setText("Remove");
        removeBtn.setEnabled(false);
        removeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeBtnActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .add(removeBtn, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 131, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(406, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(removeBtn)
        );

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 537, Short.MAX_VALUE)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 222, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * If the current item is currently errored out or complete, this item
     * will be removed from the list. 
     * @param evt
     */
    private void removeBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeBtnActionPerformed
        int index = guiThreadList.getSelectedIndex();

        if (index == -1)
        {
            this.removeBtn.setEnabled(false);
            return;
        }

        ThreadItem item = (ThreadItem) guiThreadList.getSelectedValue();

        if (item.getValue() == 100 || item.isError())
        {
            threadList.remove(index);
            this.repaint();
        }
    }//GEN-LAST:event_removeBtnActionPerformed

    private void guiThreadListValueChanged(javax.swing.event.ListSelectionEvent evt)//GEN-FIRST:event_guiThreadListValueChanged
    {//GEN-HEADEREND:event_guiThreadListValueChanged
        updateButtonState();
    }//GEN-LAST:event_guiThreadListValueChanged

    /**
     * Updates the button to be enabled or disabled depending on the completeness
     * of the currently selected job.
     */
    private void updateButtonState()
    {
        int index = guiThreadList.getSelectedIndex();

        if (index == -1)
        {
            this.removeBtn.setEnabled(false);
            return;
        }

        ThreadItem item = (ThreadItem) guiThreadList.getSelectedValue();

        if (item.getValue() == 100 || item.isError())
        {
            this.removeBtn.setEnabled(true);
        }
        else
        {
            this.removeBtn.setEnabled(false);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        java.awt.EventQueue.invokeLater(new Runnable()
        {

            public void run()
            {
                new ThreadingItemFrame().setVisible(true);

            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList guiThreadList;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton removeBtn;
    // End of variables declaration//GEN-END:variables

    /**
     * When any of the items finish or are errored out, they call this method
     * to ensure that the GUI buttons are affected appropriately. 
     * @param o
     * @param arg
     */
    public void update(Observable o, Object arg)
    {
        updateButtonState();
        if (runningProc1 != -1)
        {
            for (Object ti : threadList.toArray())
            {
                ThreadItem item = (ThreadItem) ti;
                if (item.id == runningProc1 && item.isFinished())
                {
                    runningProc1 = -1;
                }
            }
        }
        if (runningProc1 == -1)
        {
            for (Object ti : threadList.toArray())
            {
                ThreadItem item = (ThreadItem) ti;
                if (!item.isError() && !item.isFinished() && runningProc1 == -1
                        && item.id != runningProc1)// && item.id != runningProc2)
                {
                    runningProc1 = item.id;
                    item.start();
                }
            }
        }

        this.repaint();
    }

    /**
     * Called to add the thread item to the list. The frame decides whether
     * or not this frame should be run right away. 
     * @param ti
     */
    public void addToThreadList(ThreadItem ti)
    {
        threadList.addElement(ti);
        ti.addObserver(this);
        ti.id = this.procNo++;
        if (this.canStartJobs)
        {
            if (runningProc1 == -1)
            {
                runningProc1 = ti.id;
                ti.start();
            }
        }
        this.repaint();
    }

    /**
     * We don't want to close the application if there are data operations
     * going on. This method will do the check for us. 
     * @return
     */
    public boolean canClose()
    {
        return runningProc1 == -1;
    }

    public void startJobs()
    {
        this.canStartJobs = true;
        update(null, null);
    }
}
