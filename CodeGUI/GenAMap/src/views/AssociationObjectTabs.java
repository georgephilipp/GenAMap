/*
 * AssociationObjectTabs.java
 *
 * Created on Aug 12, 2009, 11:56:58 AM
 */
package views;

import javax.swing.tree.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import control.DataAddRemoveHandler;
import datamodel.AssociationSet;
import datamodel.GeneTraitAssociation;
import datamodel.MarkerSet;
import datamodel.Model;
import datamodel.Network;
import datamodel.Population;
import datamodel.TraitSet;
import datamodel.TraitSubset;
import datamodel.TraitTree;
import java.awt.Cursor;
import java.util.ArrayList;
import javax.swing.event.TreeSelectionEvent;

/**
 * The view of all data stored in GenAMap for the given team
 * @author ross
 */
public class AssociationObjectTabs extends javax.swing.JPanel
{
    /**
     * The control which holds all displayed data. This allows us to serialize
     * what tab we are on.
     */
    private DataAddRemoveHandler control;
    /**
     * Much of data management is done through the popup handler.
     */
    private PopupHandler handler;
    /**
     * The saved selection in the marker tree
     */
    private TreeSelectionEvent markerevnt;
    /**
     * The saved selection in the trait tree
     */
    private TreeSelectionEvent traitevnt;
    /**
     * The saved selection in the association tree
     */
    private TreeSelectionEvent assocevnt;
    /**
     * We sometimes change the selection when updating a trait tree, we don't
     * want multiple method calls changing the trait tree at the same time
     */
    private boolean changingTraitTree = false;
    /**
     * The current network that is selected in teh trait tree
     */
    private String currentlySelectedNetwork = "";
    /**
     * The current traitset that is selected in teh trait tree
     */
    private String currentlySelectedTraitset = "";
    /**
     * The selection path for the trait tree and possibly the assoc tree
     */
    private TreePath[] paths;
    /**
     * Similar to the trait tree, we only want one process updating the assoc tree
     * at a time
     */
    private boolean changingAssocTree = false;
    /**
     * the currently selected network in the association tree
     */
    private String currentlySelectedAssocNet = "";
    /**
     * The currently selected traitset in the association tree
     */
    private String currentlySelectedAssocTraitset = "";

    /** Creates new form AssociationObjectTabs */
    public AssociationObjectTabs()
    {
        initComponents();
    }

    /**
     * This methods sets up the display for the AOT. It creates the popup handler
     * and asks the DARH to set up the display in the trees. 
     */
    public void setup()
    {
        control = DataAddRemoveHandler.getInstance();
        control.setup(this.markerTree, this.traitTree, this.assocTree);
        this.addremoveProjPopupMenu.setInvoker(this.markerTree);

        handler = new PopupHandler(this.markerTree, this.addremoveProjPopupMenu, false, true, this);

        tabs.addChangeListener(new ChangeListener()
        {
            public void stateChanged(ChangeEvent e)
            {
                HandleTabChange();
            }
        });

        int tab = DataAddRemoveHandler.getInstance().getTab();
        this.tabs.setSelectedIndex(tab);
    }

    /**
     * This method is called when the user changes tabs between markers, traits,
     * and associations. 
     */
    public void HandleTabChange()
    {
        //System.out.println(tabs.getSelectedIndex());
        if (tabs.getSelectedIndex() == 0)
        {
            this.addremoveProjPopupMenu.setInvoker(this.markerTree);
            handler.updateHandler(markerTree, false, true);
        }
        else if (tabs.getSelectedIndex() == 1)
        {
            this.addremoveProjPopupMenu.setInvoker(this.traitTree);
            handler.updateHandler(traitTree, true, false);
        }
        else
        {
            this.addremoveProjPopupMenu.setInvoker(this.assocTree);
            handler.updateHandler(assocTree, false, false);
        }
        DataAddRemoveHandler.getInstance().setTab(tabs.getSelectedIndex());
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addremoveProjPopupMenu = new javax.swing.JPopupMenu();
        tabs = new javax.swing.JTabbedPane();
        markerTab = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        markerTree = new javax.swing.JTree();
        traitTab = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        traitTree = new javax.swing.JTree();
        assocTab = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        assocTree = new javax.swing.JTree();

        setBackground(null);

        tabs.setMinimumSize(new java.awt.Dimension(75, 15));
        tabs.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                tabsStateChanged(evt);
            }
        });

        markerTab.setBackground(null);

        jScrollPane3.setBackground(null);

        markerTree.setMaximumSize(new java.awt.Dimension(39998, 39998));
        markerTree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                markerTreeValueChanged(evt);
            }
        });
        jScrollPane3.setViewportView(markerTree);

        javax.swing.GroupLayout markerTabLayout = new javax.swing.GroupLayout(markerTab);
        markerTab.setLayout(markerTabLayout);
        markerTabLayout.setHorizontalGroup(
            markerTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 208, Short.MAX_VALUE)
        );
        markerTabLayout.setVerticalGroup(
            markerTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 260, Short.MAX_VALUE)
        );

        tabs.addTab("Markers", markerTab);

        traitTab.setBackground(null);

        jScrollPane2.setBackground(null);

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("Projects");
        traitTree.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        traitTree.setMaximumSize(new java.awt.Dimension(39998, 39998));
        traitTree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                traitTreeValueChanged(evt);
            }
        });
        jScrollPane2.setViewportView(traitTree);

        javax.swing.GroupLayout traitTabLayout = new javax.swing.GroupLayout(traitTab);
        traitTab.setLayout(traitTabLayout);
        traitTabLayout.setHorizontalGroup(
            traitTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 208, Short.MAX_VALUE)
        );
        traitTabLayout.setVerticalGroup(
            traitTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 260, Short.MAX_VALUE)
        );

        tabs.addTab("Traits", traitTab);

        assocTab.setBackground(null);

        jScrollPane1.setBackground(null);

        assocTree.setMaximumSize(new java.awt.Dimension(39998, 39998));
        assocTree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                assocTreeValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(assocTree);

        javax.swing.GroupLayout assocTabLayout = new javax.swing.GroupLayout(assocTab);
        assocTab.setLayout(assocTabLayout);
        assocTabLayout.setHorizontalGroup(
            assocTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 208, Short.MAX_VALUE)
        );
        assocTabLayout.setVerticalGroup(
            assocTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 260, Short.MAX_VALUE)
        );

        tabs.addTab("Associations", assocTab);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tabs, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tabs, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * When the user makes a selection in the marker tree, we need to find out
     * what it is and show the markerset and its populations, if applicable.
     * @param evt
     */
    private void markerTreeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_markerTreeValueChanged
        if (evt == null)
        {
            return;
        }
        ArrayList<DefaultMutableTreeNode> path;
        try
        {
            path = getPathFromSelectEvent(evt);
        }
        catch (Exception e)
        {
            return;
        }
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        AssociationView.getCurrentRunningInstance().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

        if (this.markerTab.isVisible() && path.size() == 3)
        {
            AssociationView av = AssociationView.getCurrentRunningInstance();
            System.out.println("inside 3 " + path.size());
            av.addJUNGSnpVisualization(Model.getInstance().getProject(path.get(path.size() - 2).toString()).getMarker(path.get(0).toString()));
        }
        if (this.markerTab.isVisible() && path.size() == 4)
        {
            AssociationView av = AssociationView.getCurrentRunningInstance();

            MarkerSet ms = Model.getInstance().getProject(path.get(path.size() - 2).toString()).getMarker(path.get(path.size() - 3).toString());
            Population p = ms.getPopulation(path.get(0).toString());
            try
            {
                av.addpopVisualization(ms, p);
            }
            catch (Exception e)
            {
                setCursor(Cursor.getDefaultCursor());
                AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                return;
            }
        }
        markerevnt = evt;
        setCursor(Cursor.getDefaultCursor());
        AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
    }//GEN-LAST:event_markerTreeValueChanged

    /**
     * The method that updates the trait tree view when the user makes a selection in the tree
     * @param evt
     */
    private void traitTreeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_traitTreeValueChanged
        try
        {
            if (evt == null)
            {
                return;
            }
            if (changingTraitTree)
            {
                return;
            }
            ArrayList<DefaultMutableTreeNode> path = getPathFromSelectEvent(evt);
            if (path.size() == 0)
            {
                return;
            }
            changingTraitTree = true;
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            AssociationView.getCurrentRunningInstance().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            if (path.get(0).toString().equals("subsets"))
            {
                traitTree.setSelectionPaths(paths);
                changingTraitTree = false;
                setCursor(Cursor.getDefaultCursor());
                AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                return;
            }
            if (path.size() == 3 || path.size() == 4 || path.size() == 5)
            {
                TraitSet ts = Model.getInstance().getProject(path.get(path.size() - 2).toString()).getTrait(path.get(path.size() - 3).toString());

                if (ts == null)
                {
                    changingTraitTree = false;
                    setCursor(Cursor.getDefaultCursor());
                    AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                    return;
                }

                AssociationView av = AssociationView.getCurrentRunningInstance();

                Network n = null;
                TraitTree tt = null;
                TraitSubset s = null;

                if (path.size() == 5)
                {
                    s = ts.getSubset(path.get(0).toString());

                    Object o = ts.getTraitStructure(currentlySelectedNetwork);
                    if (o instanceof Network)
                    {
                        n = (Network) o;
                    }
                    else if (o instanceof TraitTree)
                    {
                        tt = (TraitTree) o;
                    }

                    if (n == null && tt == null)
                    {
                        n = ts.getNetworks().get(0);
                    }

                    TreePath p = evt.getNewLeadSelectionPath();

                    paths = tt == null ? new TreePath[3] : new TreePath[2];
                    if (tt == null)
                    {
                        paths[2] = evt.getNewLeadSelectionPath();
                    }
                    DefaultMutableTreeNode parent = (DefaultMutableTreeNode) traitTree.getModel().getRoot();

                    paths[0] = new TreePath(parent);
                    paths[1] = new TreePath(parent);

                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(3).toString()); //project
                    paths[0] = paths[0].pathByAddingChild(parent);
                    paths[1] = paths[1].pathByAddingChild(parent);
                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(2).toString()); //trait
                    paths[0] = paths[0].pathByAddingChild(parent);
                    paths[1] = paths[1].pathByAddingChild(parent);

                    if (n != null)
                    {
                        parent = DataAddRemoveHandler.getInstance().getChildNode(parent, n.getName()); //netvurk
                        paths[1] = paths[1].pathByAddingChild(parent);
                    }
                    else
                    {
                        parent = DataAddRemoveHandler.getInstance().getChildNode(parent, tt.getName()); //traittree
                        paths[1] = paths[1].pathByAddingChild(parent);
                    }

                    traitTree.setSelectionPaths(paths);
                    if (s != null)
                    {
                        currentlySelectedTraitset = s.getName();
                    }
                }
                else if (path.size() == 4)
                {
                    paths = new TreePath[2];
                    paths[0] = evt.getNewLeadSelectionPath().getParentPath();
                    paths[1] = evt.getNewLeadSelectionPath();
                    traitTree.setSelectionPaths(paths);
                    Object o = ts.getTraitStructure(path.get(0).toString());
                    if (o instanceof Network)
                    {
                        n = (Network) o;
                    }
                    else if (o instanceof TraitTree)
                    {
                        tt = (TraitTree) o;
                    }

                    if (!currentlySelectedTraitset.equals(""))
                    {
                        s = ts.getSubset(currentlySelectedTraitset);

                        if (s != null && tt == null)
                        {
                            DefaultMutableTreeNode parent = (DefaultMutableTreeNode) traitTree.getModel().getRoot();
                            TreePath p = new TreePath(parent);

                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(2).toString()); //project
                            p = p.pathByAddingChild(parent);
                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(1).toString()); //trait
                            p = p.pathByAddingChild(parent);
                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, "subsets"); //netvurk
                            p = p.pathByAddingChild(parent);

                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, s.getName());
                            p = p.pathByAddingChild(parent);
                            traitTree.addSelectionPath(p);

                            paths = new TreePath[3];
                            paths[0] = evt.getNewLeadSelectionPath().getParentPath();
                            paths[1] = evt.getNewLeadSelectionPath();
                            paths[2] = p;
                        }
                    }
                }
                else if (ts.getNetworks().size() > 0)
                {
                    n = ts.getNetworks().get(0);
                    currentlySelectedTraitset = "";
                    TreePath p = evt.getNewLeadSelectionPath();

                    DefaultMutableTreeNode parent = (DefaultMutableTreeNode) (traitTree.getModel().getRoot());
                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(1).toString());
                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(0).toString());
                    p = p.pathByAddingChild(DataAddRemoveHandler.getInstance().getChildNode(parent, n.getName()));
                    paths = new TreePath[2];
                    paths[0] = p;
                    paths[1] = evt.getNewLeadSelectionPath();
                    traitTree.setSelectionPaths(paths);
                }
                else
                {
                    traitTree.setSelectionPath(evt.getNewLeadSelectionPath());
                    changingTraitTree = false;
                    setCursor(Cursor.getDefaultCursor());
                    AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                    return;
                }

                if (n != null)
                {
                    currentlySelectedNetwork = n.getName();
                }
                else if (tt != null)
                {
                    currentlySelectedNetwork = tt.getName();
                }

                if (n != null)
                {
                    if (this.traitTab.isVisible())
                    {
                        av.showNetworkVisualization(n, s);
                    }

                }
                if (tt != null)
                {
                    if (this.traitTab.isVisible())
                    {
                        av.showTraitTreeVisualization(tt);
                    }
                }
                traitevnt = evt;
            }

            changingTraitTree = false;
        }
        catch (Exception e)
        {
            setCursor(Cursor.getDefaultCursor());
            e.printStackTrace();
            AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
            System.err.println(e.getMessage());
        }
        setCursor(Cursor.getDefaultCursor());
        AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
    }//GEN-LAST:event_traitTreeValueChanged

    /**
     * This method updates the associtation tree when the user makes a selection
     * in the tree. 
     * @param evt
     */
    private void assocTreeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_assocTreeValueChanged

        if (evt == null)
        {
            return;
        }
        if (changingAssocTree)
        {
            return;
        }
        ArrayList<DefaultMutableTreeNode> path = getPathFromSelectEvent(evt);
        if (path.size() == 0)
        {
            return;
        }
        changingAssocTree = true;
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        AssociationView.getCurrentRunningInstance().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

        if (path.get(0).toString().equals("subsets"))
        {
            setCursor(Cursor.getDefaultCursor());
            AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
            changingAssocTree = false;
            return;
        }
        try
        {
            if (path.size() == 3 || path.size() == 4 || path.size() == 5)
            {
                AssociationSet ac;
                if (path.size() == 3)
                {
                    ac = Model.getInstance().getProject(path.get(1).toString()).getAssociation(path.get(0).toString());
                }
                else if (path.size() == 4)
                {
                    ac = Model.getInstance().getProject(path.get(2).toString()).getAssociation(path.get(1).toString());
                }
                else
                {
                    ac = Model.getInstance().getProject(path.get(3).toString()).getAssociation(path.get(2).toString());
                }

                if (ac == null)
                {
                    setCursor(Cursor.getDefaultCursor());
                    AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                    changingAssocTree = false;
                    return;
                }

                AssociationView av = AssociationView.getCurrentRunningInstance();

                Network n = null;
                TraitTree tt = null;
                GeneTraitAssociation gta = null;
                TraitSubset s = null;

                if (path.size() == 5)
                {
                    s = ac.getTraitSet().getSubset(path.get(0).toString());

                    Object o = ac.getTraitSet().getTraitStructure(currentlySelectedAssocNet);
                    if (o instanceof Network)
                    {
                        n = (Network) o;
                    }
                    else if (o instanceof TraitTree)
                    {
                        tt = (TraitTree) o;
                    }


                    if (ac.getTraitSet().getNetworks().size() == 0 && ac.getTraitSet().getTraitTrees().size() == 0)
                    {
                        setCursor(Cursor.getDefaultCursor());
                        AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                        changingAssocTree = false;
                        return;
                    }

                    if (n == null && tt == null)
                    {
                        n = ac.getTraitSet().getNetworks().get(0);
                    }

                    TreePath p = evt.getNewLeadSelectionPath();

                    paths = tt == null ? new TreePath[3] : new TreePath[2];
                    if (tt == null)
                    {
                        paths[2] = evt.getNewLeadSelectionPath();
                    }
                    DefaultMutableTreeNode parent = (DefaultMutableTreeNode) assocTree.getModel().getRoot();

                    paths[0] = new TreePath(parent);
                    paths[1] = new TreePath(parent);

                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(3).toString()); //project
                    paths[0] = paths[0].pathByAddingChild(parent);
                    paths[1] = paths[1].pathByAddingChild(parent);
                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(2).toString()); //trait
                    paths[0] = paths[0].pathByAddingChild(parent);
                    paths[1] = paths[1].pathByAddingChild(parent);
                    if (n != null)
                    {
                        parent = DataAddRemoveHandler.getInstance().getChildNode(parent, n.getName()); //netvurk
                        paths[1] = paths[1].pathByAddingChild(parent);
                    }
                    else
                    {
                        parent = DataAddRemoveHandler.getInstance().getChildNode(parent, tt.getName()); //traittree
                        paths[1] = paths[1].pathByAddingChild(parent);
                    }

                    assocTree.setSelectionPaths(paths);
                    if (s != null)
                    {
                        currentlySelectedAssocNet = s.getName();
                    }

                }
                else if (path.size() == 4)
                {
                    paths = new TreePath[2];
                    paths[0] = evt.getNewLeadSelectionPath().getParentPath();
                    paths[1] = evt.getNewLeadSelectionPath();
                    assocTree.setSelectionPaths(paths);
                    Object o = ac.getTraitStructure(path.get(0).toString());

                    if (o instanceof Network)
                    {
                        n = (Network) o;
                    }
                    else if (o instanceof TraitTree)
                    {
                        tt = (TraitTree) o;
                    }
                    else if (o instanceof GeneTraitAssociation)
                    {
                        gta = (GeneTraitAssociation) o;
                    }

                    if (!currentlySelectedAssocTraitset.equals(""))
                    {
                        s = ac.getTraitSet().getSubset(currentlySelectedAssocTraitset);

                        if (s != null)
                        {
                            DefaultMutableTreeNode parent = (DefaultMutableTreeNode) assocTree.getModel().getRoot();
                            TreePath p = new TreePath(parent);

                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(2).toString()); //project
                            p = p.pathByAddingChild(parent);
                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(1).toString()); //trait
                            p = p.pathByAddingChild(parent);
                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, "subsets"); //netvurk
                            p = p.pathByAddingChild(parent);
                            parent = DataAddRemoveHandler.getInstance().getChildNode(parent, s.getName());
                            p = p.pathByAddingChild(parent);
                            assocTree.addSelectionPath(p);
                        }
                    }


                }
                else if (ac.getTraitSet().getNetworks().size() > 0)
                {
                    n = ac.getTraitSet().getNetworks().get(0);
                    currentlySelectedAssocTraitset = "";
                    TreePath p = evt.getNewLeadSelectionPath();

                    DefaultMutableTreeNode parent = (DefaultMutableTreeNode) (assocTree.getModel().getRoot());
                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(1).toString());
                    parent = DataAddRemoveHandler.getInstance().getChildNode(parent, path.get(0).toString());
                    p = p.pathByAddingChild(DataAddRemoveHandler.getInstance().getChildNode(parent, n.getName()));
                    paths = new TreePath[2];
                    paths[0] = p;
                    paths[1] = evt.getNewLeadSelectionPath();
                    assocTree.setSelectionPaths(paths);
                }
                else
                {
                    assocTree.setSelectionPath(evt.getNewLeadSelectionPath());
                    setCursor(Cursor.getDefaultCursor());
                    AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
                    changingAssocTree = false;
                    return;
                }

                if (n != null)
                {
                    currentlySelectedAssocNet = n.getName();
                }
                else if (tt != null)
                {
                    currentlySelectedAssocNet = tt.getName();
                }

                //if (s == null)
                // s = ac.getTraitSet().getDefaultSubset();
                if (n != null)
                {
                    if (this.assocTab.isVisible())
                    {
                        av.showAssociationView(n, s, ac);
                    }
                }
                if (tt != null)
                {
                    if (this.assocTab.isVisible())
                    {
                        av.showAssociationView(tt, ac);
                    }
                }
                if (gta != null)
                {
                    if (this.assocTab.isVisible())
                    {
                        av.showThreeWayAssociationView(gta);
                    }
                }
                assocevnt = evt;
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        setCursor(Cursor.getDefaultCursor());
        AssociationView.getCurrentRunningInstance().setCursor(Cursor.getDefaultCursor());
        changingAssocTree = false;
    }//GEN-LAST:event_assocTreeValueChanged

    private void tabsStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_tabsStateChanged
        if (this.markerTab.isVisible())
        {
            this.markerTreeValueChanged(this.markerevnt);
        }
        else if (this.traitTab.isVisible())
        {
            this.traitTreeValueChanged(traitevnt);
        }
        else
        {
            this.assocTreeValueChanged(assocevnt);
        }
    }//GEN-LAST:event_tabsStateChanged

    private ArrayList<DefaultMutableTreeNode> getPathFromSelectEvent(TreeSelectionEvent evt)
    {
        ArrayList<DefaultMutableTreeNode> toReturn = new ArrayList<DefaultMutableTreeNode>();

        if (evt.getNewLeadSelectionPath() == null)
        {
            return toReturn;
        }

        DefaultMutableTreeNode n = ((DefaultMutableTreeNode) evt.getNewLeadSelectionPath().getLastPathComponent());
        toReturn.add(n);

        while ((n = (DefaultMutableTreeNode) n.getParent()) != null)
        {
            toReturn.add(n);
        }
        return toReturn;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPopupMenu addremoveProjPopupMenu;
    private javax.swing.JPanel assocTab;
    private javax.swing.JTree assocTree;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JPanel markerTab;
    private javax.swing.JTree markerTree;
    private javax.swing.JTabbedPane tabs;
    private javax.swing.JPanel traitTab;
    private javax.swing.JTree traitTree;
    // End of variables declaration//GEN-END:variables
}
